# -*- coding: utf-8 -*-
"""
Created on Thu Aug 22 15:04:15 2019

@author: rustyn
"""

import os
import tifffile
import numpy as np
import re

baseFolder = r'F:\evenField\slideAcquisition\Field_Flatness\1234\mFISH_005_flatField'


#%% Take tile config file generated by first two cells in 'Overview Tiling for CCF.ipynb' supplied by BL
# Assume same alignment across all channels.  
# Find + replace to get tile config file for remaining channels

addlChannels = ['Bandpass488', 'Bandpass561']

refTileConfig = 'TileConfig_405.txt'

for chan in addlChannels:
    
    newFile = refTileConfig.split('_')[0] + '_' + chan[-3::] + '.txt'
    nfID = open(os.path.join(baseFolder, newFile), 'wb+')
    
    
    with open(os.path.join(baseFolder, refTileConfig), 'rb') as fID:
        stringIn = fID.readline()
        
        while stringIn:
            
            # See if you need to replace 'BandpassXXX' string with current channel
            if 'Bandpass' in stringIn:
                stringIn = stringIn.replace('Bandpass405', chan)
            
            nfID.write(stringIn)
            
            stringIn = fID.readline()
            
    nfID.close()
        
# Confirms this generates desired output from FIJI -> Plugins -> Stitching -> Grid/Collection Stitching (all options unchecked)
    
#%% Generate final field-flatness correction from background in slide
# Can find tiles in slide image that are off of tissue
# For each channel, load these tiles and then average into flatness correction tile
    
# List of empty tile positions
emptyTiles = ['000_005',
              '001_005',
              '011_005',
              '000_001',
              '001_000',
              '002_000',
              '003_000']

channels = ['Bandpass405',
            'Bandpass488', 
            'Bandpass561']

prototypeString = '1-Pos_{tile}_{Channel}.tif_oMIP_.tif'
saveNameTemplate = 'AverageEmptyTile_{Channel}.tif'

for chan in channels:
    
    for i, eT in enumerate(emptyTiles):
        
        loadString = prototypeString.replace('{Channel}', chan).replace('{tile}', eT)
        
        with tifffile.TiffFile(os.path.join(baseFolder, loadString)) as tif:
            img = tif.asarray()
        
        if i == 0:
            imgAccum = img.astype('float')
        else:
            imgAccum = imgAccum + img.astype('float')
        
    imgAccum = imgAccum/len(emptyTiles)
    
    tifffile.imsave(os.path.join(baseFolder, saveNameTemplate.replace('{Channel}', chan)), imgAccum.astype('uint16'), dtype = np.uint16)
    
    
#%% Apply flat field correction to tiles
# For each channel, load associated average flat field image. 
# Correct fluorescence image for flat field
# Save MIP image into 'corrMIP' folder

channels = ['Bandpass405',
            'Bandpass488', 
            'Bandpass561']

if not os.path.exists(baseFolder + '\corrMIP'):
    os.mkdir(baseFolder + '\corrMIP')

allFiles = os.listdir(baseFolder)
fileList = []
for f in allFiles:
    if f.endswith('MIP_.tif'):
        fileList.append(f)
        
# Load three background files

for i, chan in enumerate(channels):
    
    fileHere = 'AverageEmptyTile_{channel}.tif'.replace('{channel}', chan)
    
    with tifffile.TiffFile(os.path.join(baseFolder, fileHere)) as tif:      
        
        img = tif.asarray()
        
        if i == 0:
            imgCorr = np.repeat(img[:,:,np.newaxis], len(channels), axis = 2)
        else:
            imgCorr[:,:,i] = img

imgCorr = imgCorr.astype('float')
    
chanFind = re.compile('Bandpass\d{3}')

imgList = []
imgRange = np.zeros([len(channels), 2])
for f in fileList:
    
    # Decide which file this belongs to
    chanFind = re.search('Bandpass\d{3}', f)
    chanFound = chanFind.group()[-3:]
    
    c = [i for i, k in enumerate(channels) if chanFound in k][0]
    
    # Load file to correct
    with tifffile.TiffFile(os.path.join(baseFolder, f)) as tif:
        img = tif.asarray()
    
    # Apply correction
    imgFlat = (img.astype('float') / imgCorr[:,:,c])
    
    imgList.append({'name': f,
                       'img' : imgFlat, 
                       'channel' : c})
    
    imgRange[c, 1] = np.amax([imgRange[c, 1], np.amax(imgFlat)])
    imgRange[c, 0] = np.amin([imgRange[c, 0], np.amin(imgFlat)])

#%%
for i in imgList:
    
    # Scale flattened images. 
    # Set range for each channel to 0 - 65535
    imgFlat = 65535*((i['img'] - imgRange[i['channel'], 0]) / (imgRange[i['channel'], 1] - imgRange[i['channel'], 0]))
    
    # Save corrected file
    tifffile.imsave(os.path.join(baseFolder, 'corrMIP', i['name']), imgFlat.astype('uint16'), dtype = np.uint16)
    
# These flattened images can be tiled and fused w/ 
# FIJI -> Plugins -> Stitching -> Grid/Collection Stitching (all options unchecked)
# Using 'max' as blending method looks to work best.

    
    



